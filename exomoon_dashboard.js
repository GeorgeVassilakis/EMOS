importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide!");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded!");
  await self.pyodide.loadPackage("micropip");
  const env_spec = ['https://cdn.holoviz.org/panel/wheels/bokeh-3.7.3-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.7.0/dist/wheels/panel-1.7.0-py3-none-any.whl', 'pyodide-http==0.2.1', 'holoviews', 'numpy']
  for (const pkg of env_spec) {
    let pkg_name;
    if (pkg.endsWith('.whl')) {
      pkg_name = pkg.split('/').slice(-1)[0].split('-')[0]
    } else {
      pkg_name = pkg
    }
    self.postMessage({type: 'status', msg: `Installing ${pkg_name}`})
    try {
      await self.pyodide.runPythonAsync(`
        import micropip
        await micropip.install('${pkg}');
      `);
    } catch(e) {
      console.log(e)
      self.postMessage({
	type: 'status',
	msg: `Error while installing ${pkg_name}`
      });
    }
  }
  console.log("Packages loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  const code = `
  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\nimport numpy as np\nimport panel as pn\nimport holoviews as hv\nfrom panel.template import MaterialTemplate\n\n# Initialize Panel and Holoviews extensions\npn.extension(sizing_mode='stretch_width')\nhv.extension('bokeh')\n\n# ------------------------------\n# Default Values Dictionary\n# ------------------------------\n\nDEFAULT_VALUES = {\n    'star_radius': 1.0,\n    'star_intensity': 1.0,\n    'planet_radius': 0.1,\n    'planet_distance': 0.5,\n    'transit_duration': 4.0,\n    'moon_radius': 0.03,\n    'moon_distance': 0.2,\n    'moon_orbital_period': 24.0,\n    'moon_initial_phase': 0.0,\n    'moon_orbital_inclination': 0.0,\n    'include_moon': True,\n    'time': 0.0\n}\n\n# ------------------------------\n# Simulation Functions\n# ------------------------------\n\ndef simulate_light_curve(\n    star_radius=1.0,\n    star_intensity=1.0,\n    planet_radius=0.1,\n    planet_distance=1.0,\n    transit_duration=2.0,\n    moon_radius=0.03,\n    moon_distance=0.3,\n    moon_orbital_period=24.0,\n    moon_initial_phase=0.0,\n    moon_orbital_inclination=0.0,\n    include_moon=True,\n    num_points=1000\n):\n    """\n    Simulate a transit light curve for a star with a planet and its moon.\n    Moon orbit can be inclined relative to the transit plane.\n    """\n    # Add padding before and after transit for better visualization\n    padding_factor = 1.5  # Amount of extra time to show on each side\n    total_duration = transit_duration * (1 + 2 * padding_factor)\n    time = np.linspace(-total_duration/2, total_duration/2, num_points)\n    flux = np.ones_like(time) * star_intensity\n    \n    # Only calculate transit effects within the actual transit duration\n    transit_mask = (time >= -transit_duration/2) & (time <= transit_duration/2)\n    transit_time = time[transit_mask]\n    \n    # Convert inclination to radians\n    inclination_rad = np.radians(moon_orbital_inclination)\n    \n    # Planet position (in transit plane)\n    planet_x = transit_time * (2 * star_radius / transit_duration)\n    planet_y = np.full_like(transit_time, planet_distance)\n    \n    # Calculate moon position with inclination effects\n    angles = 2 * np.pi * ((transit_time / moon_orbital_period) + moon_initial_phase)\n    \n    # Moon position relative to planet before projection\n    moon_rel_x = moon_distance * np.cos(angles)\n    moon_rel_y = moon_distance * np.sin(angles)\n    \n    # Project moon position considering orbital inclination\n    moon_x = planet_x + moon_rel_x  # x-coordinate unchanged\n    moon_y = planet_y + moon_rel_y * np.cos(inclination_rad)\n    moon_z = moon_rel_y * np.sin(inclination_rad)\n\n    \n    # Calculate overlap areas during transit\n    star_planet_overlap = transit_area_vectorized(planet_x, planet_y, planet_radius, star_radius)\n    \n    if include_moon:\n        # Only consider moon transit when it's in front of the star (z >= 0)\n        moon_in_front = moon_z >= 0\n        star_moon_overlap = np.zeros_like(transit_time)\n        star_moon_overlap[moon_in_front] = transit_area_vectorized(\n            moon_x[moon_in_front], \n            moon_y[moon_in_front], \n            moon_radius, \n            star_radius\n        )\n        \n        # Calculate planet-moon overlap only when moon is in front\n        planet_moon_overlap = np.zeros_like(transit_time)\n        planet_moon_overlap[moon_in_front] = circle_overlap_vectorized(\n            planet_x[moon_in_front], \n            planet_y[moon_in_front], \n            planet_radius,\n            moon_x[moon_in_front], \n            moon_y[moon_in_front], \n            moon_radius\n        )\n    else:\n        star_moon_overlap = 0\n        planet_moon_overlap = 0\n    \n    # Total overlap area considering overlaps\n    total_overlap = star_planet_overlap + star_moon_overlap - planet_moon_overlap\n    \n    # Apply transit effects only during transit\n    flux[transit_mask] -= (total_overlap / (np.pi * star_radius**2)) * star_intensity\n    \n    return time, flux\n\ndef transit_area_vectorized(x, y, radius, star_radius):\n    """\n    Vectorized calculation of the overlap area between the star and a transiting body.\n    """\n    distance = np.sqrt(x**2 + y**2)\n    area = np.zeros_like(distance)\n    \n    # Case 1: No overlap\n    no_overlap = distance >= (star_radius + radius)\n    area[no_overlap] = 0\n    \n    # Case 2: Complete overlap (transiting body entirely within the star)\n    complete_overlap = distance <= (star_radius - radius)\n    area[complete_overlap] = np.pi * radius**2\n    \n    # Case 3: Partial overlap\n    partial_overlap = ~(no_overlap | complete_overlap)\n    d = distance[partial_overlap]\n    r, R = radius, star_radius\n    argument = (d**2 + r**2 - R**2) / (2*d*r)\n    argument_clipped = np.clip(argument, -1, 1)\n    phi = 2 * np.arccos(argument_clipped)\n\n    theta = 2 * np.arccos((d**2 + R**2 - r**2) / (2 * d * R))\n    area1 = 0.5 * r**2 * (phi - np.sin(phi))\n    area2 = 0.5 * R**2 * (theta - np.sin(theta))\n    area[partial_overlap] = area1 + area2\n    \n    return area\n\ndef circle_overlap_vectorized(x1, y1, r1, x2, y2, r2):\n    """\n    Vectorized calculation of the overlap area between two circles.\n    """\n    distance = np.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n    area = np.zeros_like(distance)\n    \n    # Case 1: No overlap\n    no_overlap = distance >= (r1 + r2)\n    area[no_overlap] = 0\n    \n    # Case 2: Complete overlap (one circle entirely within the other)\n    complete_overlap = distance <= np.abs(r1 - r2)\n    area[complete_overlap] = np.pi * np.minimum(r1, r2)**2\n    \n    # Case 3: Partial overlap\n    partial_overlap = ~(no_overlap | complete_overlap)\n    d = distance[partial_overlap]\n    alpha = np.arccos((d**2 + r1**2 - r2**2) / (2 * d * r1))\n    beta = np.arccos((d**2 + r2**2 - r1**2) / (2 * d * r2))\n    area1 = r1**2 * alpha\n    area2 = r2**2 * beta\n    area3 = 0.5 * np.sqrt((-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))\n    area[partial_overlap] = area1 + area2 - area3\n    \n    return area\n\ndef plot_light_curve(star_radius, star_intensity, planet_radius, planet_distance, transit_duration,\n                     moon_radius, moon_distance, moon_orbital_period, moon_initial_phase, \n                     moon_orbital_inclination, include_moon):\n    """\n    Generate an interactive Holoviews plot for the transit light curve.\n    """\n    time, flux = simulate_light_curve(\n        star_radius=star_radius,\n        star_intensity=star_intensity,\n        planet_radius=planet_radius,\n        planet_distance=planet_distance,\n        transit_duration=transit_duration,\n        moon_radius=moon_radius,\n        moon_distance=moon_distance,\n        moon_orbital_period=moon_orbital_period,\n        moon_initial_phase=moon_initial_phase,\n        moon_orbital_inclination=moon_orbital_inclination,\n        include_moon=include_moon\n    )\n    \n    title = 'Exomoon Transit Light Curve' if include_moon else 'Planet Transit Light Curve'\n    \n    # Calculate y-axis range to show the transit clearly while maintaining context\n    flux_min = np.min(flux)\n    flux_max = np.max(flux)\n    flux_range = flux_max - flux_min\n    y_padding = flux_range * 0.1\n    \n    curve = hv.Curve((time, flux), 'Time (hours)', 'Normalized Flux').opts(\n        title=title,\n        responsive=True,\n        height=500,\n        line_width=2,\n        color='#1f77b4',\n        tools=['hover', 'pan', 'wheel_zoom', 'box_zoom', 'reset', 'save'],\n        toolbar='above',\n        xlabel='Time (hours)',\n        ylabel='Normalized Flux',\n        ylim=(flux_min - y_padding, flux_max + y_padding),\n        fontsize={'title': 16, 'labels': 14, 'ticks': 12},\n        show_grid=True,\n        gridstyle={'grid_line_dash': 'dotted', 'grid_line_width': 0.5},\n    )\n    \n    return curve\n\ndef create_orbital_diagram(star_radius, planet_radius, planet_distance, moon_radius, \n                           moon_distance, moon_initial_phase, moon_orbital_inclination,\n                           include_moon, time_fraction=0):\n    """\n    Create an SVG orbital diagram showing the current configuration of the system.\n    Includes projection of inclined moon orbit.\n    """\n    # SVG viewport and scaling parameters\n    view_size = 500\n    margin = 60\n    scale = (view_size - 2 * margin) / (4 * star_radius)\n    \n    # Center of the viewport\n    cx = view_size / 2\n    cy = view_size / 2\n    \n    # Calculate positions\n    planet_x = time_fraction * (2 * star_radius)\n    planet_y = planet_distance\n    \n    # Convert inclination to radians\n    inclination_rad = np.radians(moon_orbital_inclination)\n    \n    # Calculate moon position with inclination\n    moon_angle = 2 * np.pi * moon_initial_phase\n    moon_rel_x = moon_distance * np.cos(moon_angle)\n    moon_rel_y = moon_distance * np.sin(moon_angle)\n    \n    moon_x = planet_x + moon_rel_x\n    moon_y = planet_y + moon_rel_y * np.cos(inclination_rad)\n    moon_z = moon_rel_y * np.sin(inclination_rad)\n    \n    # Generate points for moon's orbital ellipse\n    orbit_points = []\n    num_points = 100\n    for angle in np.linspace(0, 2*np.pi, num_points):\n        orbit_rel_x = moon_distance * np.cos(angle)\n        orbit_rel_y = moon_distance * np.sin(angle)\n        orbit_x = planet_x + orbit_rel_x\n        orbit_y = planet_y + orbit_rel_y * np.cos(inclination_rad)\n        orbit_points.append((orbit_x * scale + cx, orbit_y * scale + cy))\n    \n    # Create SVG\n    svg = f'''\n    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {view_size} {view_size}">\n        <!-- Background -->\n        <rect width="{view_size}" height="{view_size}" fill="#f8f9fa"/>\n        \n        <!-- Coordinate system -->\n        <line x1="{margin}" y1="{cy}" x2="{view_size-margin}" y2="{cy}" \n              stroke="#ccc" stroke-width="1" stroke-dasharray="4"/>\n        <line x1="{cx}" y1="{margin}" x2="{cx}" y2="{view_size-margin}" \n              stroke="#ccc" stroke-width="1" stroke-dasharray="4"/>\n        \n        <!-- Star -->\n        <circle cx="{cx}" cy="{cy}" r="{star_radius * scale}" \n                fill="#ffde00" stroke="#ff9900" stroke-width="2"/>\n        \n        <!-- Planet orbit line -->\n        <line x1="{cx - 2*star_radius*scale}" y1="{cy + planet_distance*scale}" \n              x2="{cx + 2*star_radius*scale}" y2="{cy + planet_distance*scale}" \n              stroke="#666" stroke-width="1" stroke-dasharray="4"/>\n    '''\n    \n    # Add moon orbit ellipse if included\n    if include_moon:\n        path_d = f"M {orbit_points[0][0]},{orbit_points[0][1]}"\n        for x, y in orbit_points[1:]:\n            path_d += f" L {x},{y}"\n        path_d += " Z"\n        \n        svg += f'''\n        <!-- Moon orbit -->\n        <path d="{path_d}" fill="none" stroke="#999" \n              stroke-width="1" stroke-dasharray="4"/>\n        '''\n    \n    # Add planet\n    svg += f'''\n    <!-- Planet -->\n    <circle cx="{cx + planet_x*scale}" cy="{cy + planet_y*scale}" \n            r="{planet_radius * scale}" fill="#666"/>\n    '''\n    \n    # Add moon if included\n    if include_moon:\n        # Adjust moon size based on z-position (perspective effect)\n        z_scale = 1.0 - 0.2 * (moon_z / moon_distance)\n        moon_apparent_radius = moon_radius * scale * z_scale\n        \n        svg += f'''\n        <!-- Moon -->\n        <circle cx="{cx + moon_x*scale}" cy="{cy + moon_y*scale}" \n                r="{moon_apparent_radius}" fill="#999"\n                opacity="{1.0 if moon_z >= 0 else 0.5}"/>\n        '''\n    \n    svg += '</svg>'\n    return svg\n\n# ------------------------------\n# Create Widgets with Help Texts\n# ------------------------------\n\ndef create_slider(name, start, end, step, value, help_text):\n    slider = pn.widgets.FloatSlider(\n        name=name,\n        start=start,\n        end=end,\n        step=step,\n        value=value,\n        sizing_mode='stretch_width',\n        tooltips=True\n    )\n    help_pane = pn.pane.Markdown(f"**{name}**: {help_text}", sizing_mode='stretch_width')\n    return pn.Column(slider, help_pane)\n\n# Star parameters\nstar_radius_slider = create_slider(\n    name='Star Radius (R\u2609)',\n    start=0.5,\n    end=2.0,\n    step=0.1,\n    value=DEFAULT_VALUES['star_radius'],\n    help_text='Radius of the star in solar radii (R\u2609).'\n)\nstar_intensity_slider = create_slider(\n    name='Star Intensity',\n    start=0.5,\n    end=1.5,\n    step=0.1,\n    value=DEFAULT_VALUES['star_intensity'],\n    help_text='Normalized intensity of the star.'\n)\n\n# Planet parameters\nplanet_radius_slider = create_slider(\n    name='Planet Radius (R*)',\n    start=0.05,\n    end=0.2,\n    step=0.005,\n    value=DEFAULT_VALUES['planet_radius'],\n    help_text='Radius of the planet in stellar radii (R*).'\n)\nplanet_distance_slider = create_slider(\n    name='Planet Impact Parameter (R*)',\n    start=0.0,\n    end=1.0,\n    step=0.01,\n    value=DEFAULT_VALUES['planet_distance'],\n    help_text='Impact parameter of the planet in stellar radii (R*).'\n)\ntransit_duration_slider = create_slider(\n    name='Transit Duration (hours)',\n    start=1.0,\n    end=10.0,\n    step=0.5,\n    value=DEFAULT_VALUES['transit_duration'],\n    help_text='Duration of the transit in hours.'\n)\n\n# Moon parameters\nmoon_radius_slider = create_slider(\n    name='Moon Radius (R*)',\n    start=0.01,\n    end=0.05,\n    step=0.001,\n    value=DEFAULT_VALUES['moon_radius'],\n    help_text='Radius of the moon in stellar radii (R*).'\n)\nmoon_distance_slider = create_slider(\n    name='Moon Distance from Planet (R*)',\n    start=0.1,\n    end=0.5,\n    step=0.01,\n    value=DEFAULT_VALUES['moon_distance'],\n    help_text='Distance of the moon from the planet in stellar radii (R*).'\n)\nmoon_orbital_period_slider = create_slider(\n    name='Moon Orbital Period (hours)',\n    start=1.0,\n    end=48.0,\n    step=1.0,\n    value=DEFAULT_VALUES['moon_orbital_period'],\n    help_text='Orbital period of the moon around the planet in hours.'\n)\nmoon_initial_phase_slider = create_slider(\n    name='Moon Initial Phase',\n    start=0.0,\n    end=1.0,\n    step=0.05,\n    value=DEFAULT_VALUES['moon_initial_phase'],\n    help_text='Initial phase of the moon\\'s orbit (0 to 1).'\n)\nmoon_inclination_slider = create_slider(\n    name='Moon Orbital Inclination (\xb0)',\n    start=0.0,\n    end=90.0,\n    step=1.0,\n    value=DEFAULT_VALUES['moon_orbital_inclination'],\n    help_text='Inclination of moon\\'s orbit relative to transit plane (0\xb0 = edge-on, 90\xb0 = face-on).'\n)\n\n# Include Moon Toggle\ninclude_moon_toggle = pn.widgets.Checkbox(\n    name='Include Moon',\n    value=DEFAULT_VALUES['include_moon'],\n    sizing_mode='stretch_width'\n)\ninclude_moon_help = pn.pane.Markdown(\n    "**Include Moon**: Toggle to include or exclude the moon from the simulation.",\n    sizing_mode='stretch_width'\n)\n\n# Create a time slider for the orbital diagram\ntime_slider = pn.widgets.FloatSlider(\n    name='Transit Time',\n    start=-1,\n    end=1,\n    step=0.1,\n    value=DEFAULT_VALUES['time'],\n    sizing_mode='stretch_width'\n)\n\n# Create the orbital diagram pane\norbital_diagram = pn.pane.SVG(sizing_mode='stretch_width', height=500)\n\n# ------------------------------\n# Reset Button Function\n# ------------------------------\n\ndef reset_parameters(event):\n    """Reset all parameters to their default values"""\n    star_radius_slider[0].value = DEFAULT_VALUES['star_radius']\n    star_intensity_slider[0].value = DEFAULT_VALUES['star_intensity']\n    planet_radius_slider[0].value = DEFAULT_VALUES['planet_radius']\n    planet_distance_slider[0].value = DEFAULT_VALUES['planet_distance']\n    transit_duration_slider[0].value = DEFAULT_VALUES['transit_duration']\n    moon_radius_slider[0].value = DEFAULT_VALUES['moon_radius']\n    moon_distance_slider[0].value = DEFAULT_VALUES['moon_distance']\n    moon_orbital_period_slider[0].value = DEFAULT_VALUES['moon_orbital_period']\n    moon_initial_phase_slider[0].value = DEFAULT_VALUES['moon_initial_phase']\n    moon_inclination_slider[0].value = DEFAULT_VALUES['moon_orbital_inclination']\n    include_moon_toggle.value = DEFAULT_VALUES['include_moon']\n    time_slider.value = DEFAULT_VALUES['time']\n\nreset_button = pn.widgets.Button(\n    name='Reset Parameters',\n    button_type='primary',\n    sizing_mode='stretch_width'\n)\nreset_button.on_click(reset_parameters)\n\ndef update_orbital_diagram(*args, **kwargs):\n    """Update the orbital diagram based on current parameter values"""\n    svg = create_orbital_diagram(\n        star_radius=star_radius_slider[0].value,\n        planet_radius=planet_radius_slider[0].value,\n        planet_distance=planet_distance_slider[0].value,\n        moon_radius=moon_radius_slider[0].value,\n        moon_distance=moon_distance_slider[0].value,\n        moon_initial_phase=moon_initial_phase_slider[0].value,\n        moon_orbital_inclination=moon_inclination_slider[0].value,\n        include_moon=include_moon_toggle.value,\n        time_fraction=time_slider.value\n    )\n    orbital_diagram.object = svg\n\n# Bind all parameters to update the orbital diagram\nfor param in [star_radius_slider[0], planet_radius_slider[0], planet_distance_slider[0],\n              moon_radius_slider[0], moon_distance_slider[0], moon_initial_phase_slider[0],\n              moon_inclination_slider[0], include_moon_toggle, time_slider]:\n    param.param.watch(update_orbital_diagram, 'value')\n\n# ------------------------------\n# Organize Controls into Tabs\n# ------------------------------\n\ncontrols = pn.Tabs(\n    ('\u2b50 Star', pn.Column(\n        star_radius_slider,\n        star_intensity_slider,\n        sizing_mode='stretch_width',\n        margin=(10, 5)\n    )),\n    ('\U0001fa90 Planet', pn.Column(\n        planet_radius_slider,\n        planet_distance_slider,\n        transit_duration_slider,\n        sizing_mode='stretch_width',\n        margin=(10, 5)\n    )),\n    ('\U0001f315 Moon', pn.Column(\n        moon_radius_slider,\n        moon_distance_slider,\n        moon_orbital_period_slider,\n        moon_initial_phase_slider,\n        moon_inclination_slider,\n        include_moon_toggle,\n        include_moon_help,\n        sizing_mode='stretch_width',\n        margin=(10, 5)\n    )),\n    sizing_mode='stretch_width'\n)\n\n# ------------------------------\n# Create the Interactive Plot\n# ------------------------------\n\ninteractive_plot = pn.bind(\n    plot_light_curve,\n    star_radius=star_radius_slider[0],\n    star_intensity=star_intensity_slider[0],\n    planet_radius=planet_radius_slider[0],\n    planet_distance=planet_distance_slider[0],\n    transit_duration=transit_duration_slider[0],\n    moon_radius=moon_radius_slider[0],\n    moon_distance=moon_distance_slider[0],\n    moon_orbital_period=moon_orbital_period_slider[0],\n    moon_initial_phase=moon_initial_phase_slider[0],\n    moon_orbital_inclination=moon_inclination_slider[0],\n    include_moon=include_moon_toggle\n)\n\n# ------------------------------\n# Create the Template and Layout\n# ------------------------------\n\ntemplate = MaterialTemplate(title='Exomoon Transit Simulator')\n\n# Place controls first, then the reset button at the bottom\ntemplate.sidebar.append(\n    pn.Column(\n        pn.pane.Markdown("### Simulation Controls", sizing_mode='stretch_width'),\n        controls,\n        reset_button,  # Moved the reset button below the controls\n        sizing_mode='stretch_width'\n    )\n)\n\nmain_tabs = pn.Tabs(\n    ('\U0001f4c8 Light Curve', pn.Column(\n        pn.pane.HoloViews(interactive_plot, sizing_mode='stretch_both')\n    )),\n    ('\U0001f52d Orbital View', pn.Column(\n        pn.pane.Markdown("### System Configuration", sizing_mode='stretch_width'),\n        orbital_diagram,\n        time_slider,\n        sizing_mode='stretch_width'\n    )),\n    sizing_mode='stretch_both'\n)\n\ntemplate.main.append(main_tabs)\n\n# Initialize the orbital diagram\nupdate_orbital_diagram()\n\n# Make the dashboard servable\ntemplate.servable()\n\n\nawait write_doc()
  `

  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(code)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()